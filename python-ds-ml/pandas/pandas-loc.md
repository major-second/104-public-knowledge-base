- 前置[[pandas-index]]
- [文档](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html)
- row indexer
  - 基础：单点
    - `.loc['2014-01-20']`
  - [[timestamps]]相关
    - `.loc['2014-01-20':'2014-01-22']`
    - `.loc['2006-12']`
  - 切片
    - 如果df [[pandas-index]]没有被排序不放心切片，可以传入
      - > Conditional that returns a boolean Series
        - `df.loc[df['a'] > 10, ['a’, 'c']]`
        - 拓展
          - `df[df['symbol'].str.contains('USDT')]`
          - `df['year'] = df['timestamp'].dt.year`
            - 这是[[timestamps]]使用
          - 总之就是减少[[pandas-apply]]，提高效率
      - > Multiple conditional using & that returns a boolean Series
        - 复杂的：可以先取出values再用[[numpy-bool-array]]操作
      - > Callable that returns a boolean Series
        - input是整个 [[series-dataframe]]
    - 第三个分量
      - 比如`1, -1, -4`这种都行，表示“间隔条目数”
      - 所以和第一第二个分量的“数据类型”未必相同
        - 典型第一第二个分量可能是[[timestamps]]，第三个可能是整数
- row and column indexers
  - `df.loc[0, 'key'] = value`这样比`df['key'][0] = value`好
  - 后者会报[[warning]]，和[[general-copy]]有关
    - [参考](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy)
    - 这个文档不一定很准确，可参考[这个知乎回答](https://zhuanlan.zhihu.com/p/416898038)
  - 当然，大多数时候，[[pandas-index]]并不是`0`之类的，而是[[timestamps]]
    - 此时必须用`df.index`取出
    - 例如`df.loc[df.index[0], 'key']`
    - 注意后文的`.iloc`并不能`df.iloc[0, 'key']`
  - 千万不能漏了`.loc`写成了`df[0, 'key']`，否则变成了取column
- loc常见坑
  - 和普通python的`[]`切片不同之处
    - `.loc[]`**切片含两端**
    - `.loc`默认是“绝对”的索引，而不是相对
      - `.loc[0]`中的0是某个数据条目的一个属性（`index`），相当于某种特殊feature，而不是其在某个序列中的排序
      - 也就是“二次”切片时不能“相对”切。例如`d.loc[3:4]`的结果就不能再`.loc[0]`了！
      - 所以`.loc`似乎天然适合用于处理关于日期时间的索引切片
    - `.loc[单个]`和`.loc[start:end]`出来的数据类型不一样（这点不同于python原生字符串切片）
      - 所以对两种出来结果再切片时效果也当然不同
  - 在数据量大时`.loc`占用资源多，所以可以考虑预先存时间戳到索引位置的[[look-up]]等，这是时空[[tradeoff]]
- `.iloc`：按顺序0开始取
  - 但这个不能`.iloc[<row_indexer>, <column_indexer>]`
- `.at`: 常用于一个元素本身是df等复杂对象，这个不能用loc
  - `df[col] = pd.Series(dtype=object)`
  - `df.at[row, col] = sub_df`
- [[multi-index-loc]]