- https://oi-wiki.org/graph/shortest-path/#bellman-ford-%E7%AE%97%E6%B3%95
- 单源，给出[[graph/save#adjacency-list]]时，最适合
- 以边为主
  - 每次看（单源）最后以这个边为**结尾**时，能不能更好
  - 即$dis(a,b)=min(dis(a,b), dis(a,c)+w(c,b))$
  - $a$确定是源点
  - 所以需要存每个点有哪些**入边**
- 相当于[[dp]]分拆子问题
  - 每次过一遍所有边，获得单源最多经过$i$条边的最短路，$i$不断增多
  - 如果$i$大于等于$n$了说明有负环！
    - 当然，如果没有，不能说明没有负环
    - 因为可能连通不过去。你这是单源
    - [[reduction]]手段：虚拟一个新节点用0连所有
  - 所以这个算法复杂度高但不怕负
## SPFA
- 用一个队列维护松弛过的，进行[[bfs]]
- 直观来说
  - 上一轮对于1 -> 3这个问题，发现1 -> 2 -> 3比直接1 -> 3短，那么下一轮3 -> 4这条边就可能“有用”
  - 否则，3 -> 4这条边该没用还是没用，不用再考察
  - 相当于某种[[enumerate#pruning]]
- 也可判断是否有负环