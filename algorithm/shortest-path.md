- https://oi-wiki.org/graph/shortest-path/
# dijkstra
- 贪心[[greedy]]地每次找到离单源最近
- 用[[adapter]]优先队列或二叉堆维护其它点到出发点的距离
  - 不是“到前沿的距离”！！（对比[[minimum-spanning-tree]]中的prim）
- 如果用优先队列，由于不能删除之前不要的点，故相比来说较慢
- 证明：[[induction]]，每一步都保证最优
  - 你填进一个点时，如果经由其它点到达，只会更差
  - 这里用到了无负权
  - 一条边对比了许多条边，所以不能整张图加某个数。对比[[minimum-spanning-tree]]中的prim算法
- 注意：不需要专门维护“访问过”点集。因为折返回去无负权，路不会更短，所以不满足条件，不进frontier
- 例子：从$(0,0)$到$(i,j)$最短路
  - 不需要[[graph/save]]存图，直接由规则知道每个点相邻的是哪些点
  - 每次循环中，选（堆中）最小的点（也就是单源最短路）考察，并按规则往frontier加其相邻点（具体地，相邻不越界且路径更优就加）
# floyd
- 三重循环，每次“放松”一个可能中转点
- 是一种[[dp]]算法，每次对$O(n^2)$个子问题都进行优中选优
- 逻辑上两重循环，实现上三重循环
- 实际操作中可以状态压缩（容易论证压缩不影响）
```python
# 初始时f是权（有限或正无穷）
for k in range(1, n + 1):
    for x in range(1, n + 1):
        for y in range(1, n + 1):
            f[x][y] = min(f[x][y], f[x][k] + f[k][y])
```
# bellman-ford算法
- 单源，在给出边列表时很适合
- 以边为主
  - 每次看（单源）最后以这个边为结尾时，能不能更好
  - 即$dis(a,b)=min(dis(a,b), dis(a,c)+w(c,b))$
  - 所以需要存每个点有哪些入边
- 每次过一遍所有边，获得单源最多经过$i$条边的最短路，$i$不断增多
  - 如果$i$大于等于$n$了说明有负环！
    - 当然，如果没有，不能说明没有负环
    - 因为可能连通不过去。你这是单源
  - 所以这个算法复杂度高但不怕负
# 拓展
- floyd和bell的放松可以联系[[3-search]]中3.6节找启发式函数的“放松”
## SPFA
- 是[bellman-ford](#bellman-ford算法)拓展
- 用一个队列维护松弛过的，进行[[bfs]]
- 也就是，如果1 - 2 - 3 - 4是一条较优路径，不会先 1 - 3 - 4再 1 - 2 - 3 - 4，而是先找到 1 - 2，然后2出队列考察时找到 1 - 2 - 3，以此类推
- 方便判断是否有负环