- [参考](https://en.wikipedia.org/wiki/Memoization)
  - 这是专有造出来的，不要写成memorization
# 对比
## 对比[[dp]]
- 很多时候[[dp]]快，memo有[[oi-wiki-basic/recursion]]调用可能被卡
- 但是有时memo早早搜到相当于[[enumerate#pruning]]了，更快
## 对比[[oi-wiki-basic/recursion]]
- 那当然快了
- 可以基于[[oi-wiki-basic/recursion]]，先用[[oi-wiki-basic/recursion]]理清思路，再改成memo
# 例子
- https://leetcode.cn/problems/can-i-win/submissions/
  - 注意：不能傻傻地从`0b11111111`一点一点走到`0b00000000`这样，否则TLE
  - 应该从0开始记忆化搜索。
  - 这两者有啥区别？最坏复杂度一样，但是记忆化搜索有可能中途返回
    - 所以说这题memo比[[dp]]快
- https://leetcode.cn/problems/generate-parentheses/
  - 如果要递归，那么计算`n`对应结果时，提前记住之前所有结果当然很有帮助
  - 注：观察：比如`n=3`，那么就是`()`中间插入2个`(`2个`)`，插入的时候，可能是“始终不侵犯最左侧`(`”，“第一对侵犯”，“第二对侵犯”，“两对都侵犯”4种可能。其中“始终不侵犯”就对应了`n=2`的2种答案。共5种答案
- [[486-predict-the-winner]]
- 每次三种操作之一
  - 能整除2的除以2
  - 能整除3的除以3
  - 减一
  - 多少次到1
  - 关键：你不可能一次减太多
    - 比如减两次再除以2，不合理！
  - 所以原始解法[[oi-wiki-basic/recursion]]，$T(n)=T(n/3)+T(n/2)+O(1)$
    - 这当然比[[dp]]快，根据[[master-theorem]]
    - 注意这里是[[forward-backward]]思想，正逆向思考结果不同
  - 记忆化搜索可以更快