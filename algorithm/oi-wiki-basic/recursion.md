- 前置[[func]]
- https://oiwiki.org/basic/divide-and-conquer/
# 概述
- 递归：分为子问题，自己调用自己
  - 如果自己太特殊了，子问题和自己相似但不完全相同，那可能要增加参数
  - 例如[[60-permutation-sequence]]
    - 自己是排列`12...n`
    - 递归时可能不一定排列`12...n`这样的，所以要增加参数
- 递归的精髓
  - `明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。`
  - 参考[[116-populating-next-right-pointers-in-each-node]]
    - 一是明白函数执行条件
    - 二是明白函数执行后结论
- 优点：写起来简单。缺点：时空等效率低
  - 有时可以[[dp]], [[记忆化搜索]]获得更高效率
- 如果各部分不独立，有重复子问题，就不要用分治，而是用动态规划
- 怎么分？
  - 如果把$n$分成$n+1$和$1$并不好，那就考虑$n/2$和$n/2$试试，往往可提高效率
  - 也就是递归和[[divide-and-conquer]]常常联系
# 出口条件
- 记住一定要写出口条件
  - 这时要注意[[special-case]]！而且其实出口往往都是[[special-case]]
# 使递推关系最简单
- 比如出现二元递推时，经常出现“一动一不动”
- 一个举例：[[10-regular-expression-matching]]
  - 三种递推关系
  - `ab, ab`变成`b, b`
  - `a*`直接被去除，不匹配任何东西
  - 在`p`中有`a*`时，`s`中的`a`直接被去除一个
    - 这里千万不要写`p`中的`a*`和`s`中的`a`一起被去除，因为这就不是最不可细分的操作了
# 和[[dp]]关系
- 一般和[[dp]]方向相反
  - 例如[[10-regular-expression-matching]]，递归从字符串前向后，而[[dp]]先看后缀是否匹配再看前面
- “可能性”数量对应
  - 例如[[10-regular-expression-matching]]，三种递推关系
    - 则在递归解法中，出现三次调用自身
    - 在递推解法中，出现三次读取自身数组的（已经计算出的）值