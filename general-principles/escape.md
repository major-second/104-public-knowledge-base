# 理论
- [[encode-decode]]“码”不够了
# 实例
- [[meta-programming]]
- [[regex]]中
  - `\.`才是一个点字符，否则表示任意字符
  - `\(`才是字面的括号
  - 等等
  - 但[[find-grep]]中的`grep`又不同，括号是反过来的，`(`匹配字面括号，`\(`才是特殊含义的元字符，反正你两个得转一个
- shell转义非常繁琐，有时你可能都得考虑[[workaround]]……
  - [[11-basic-scripting-partA]]中例子（单双引号区别）
    - `echo -n "$SHELL "; echo -n '$SHELL '; echo -n "\$SHELL "`
    - 输出`/bin/bash $SHELL $SHELL`
  - [[shrc]]中例子
    - `alias monitor-disk="watch -d -n 60 'du -h ~/ | grep \"[0-9]G\\s\"'"`
    - 实际上真正`monitor-disk`时，是不断执行`du -h ~/ | grep "[0-9]K\s"`
    - 也就是双引号里的`", \, "`写作了`\", \\, \"`
  - [[linux/zip-unzip]]中例子
    - `zip -r tmp.zip dir -x "dir/subdir/*"`
      - 可以尝试`echo ./*; echo "./*"`看区别
  - 相比标准的bash, [[zsh]]是[[non-standard]]可能造成额外麻烦，比如`[]`需要转义
- [[powershell/basics]]中也有不少
  - 而且结合linux，比如[[wsl-command]]中的例子更麻烦
    - `wsl -e bash -c 'echo -e \\033[35m $(uname -a) \\033[0m'`：共转义2次
    - 上面例子中`wsl -e bash -c`并不本质。你直接linux终端中`echo -e \\033[35m $(uname -a) \\033[0m`也是一样的结果
    - 解说：外面没有引号保护，所以一来`\\`变成`\`
    - 然后再`\033[35m`这种看成一个整体表示变成紫色，参考[[echo]]
- `python`的[[f-string]]中，大括号等需要转义