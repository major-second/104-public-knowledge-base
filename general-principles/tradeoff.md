# 总体原则
- [[marginal#边际产值相等表示最优]]
- [[inada-condition]]
- 多目标优化，需要[[utility-function]]效用函数，明确你想要什么
  - 有时有天然的[[utility-function]]
    - 如[[2-eval]]所述，在tradeoff训练集占多大时，天然的[[utility-function]]就是模型最终表现
  - 有时需要自己定义/finetune [[utility-function]]
    - 如[[2-eval]]中由P-R曲线计算$F_1$
    - 如正则化项乘以$\lambda$，典型的如[[11-feature-selection]]的岭回归
      - 这里的“调”就是“调超参”的意思
  - 指定越大越好的[[utility-function]]后（或越小越好的成本cost后），如果可加，往往出现一个增函数，一个减函数，相加得到一个极小值点，使得成本最小
    - 如[[1-monitor-fragmentation]]
    - 如[[MSE#bias-variance tradeoff]]
- 如果不定义，则往往
  - 可以考察
    - 指定一维（甲）不变时，另一维（乙）的表现
      - [[UMP]]指定[[power-level#水平]]不变
    - [[p-value]]指定某个点必须被拒绝
  - 还可以指定多个甲取值，看各个情况下最佳的乙，这就是[[pareto-efficient]]帕累托前沿
    - 例：[[2-eval]]的P-R曲线
  - 当然可能[[confidence-interval]]这样纯凭感觉
# 时空tradeoff
- 存显存 ->(`1`) 存内存 ->(`2`) 存硬盘 ->(`3`) 啥也不存
  - 参考[[memory]], [[resource-management/disk]]
- 如[[general-principles/cache]]空间换时间
  - 体现`2, 3`
- 如[[dataloader]] `pin_memory`空间换时间
  - 体现`2`
- 如[[pandas-loc]]提到的
  - 体现`2, 3`
- 如[[preprocessing]]放到GPU，GPU空间换读取到GPU的时间
  - 体现`1`
- 较为极端的空间换时间
  - [[counting-sort]]
  - [[hash]]
  - [[打表]]
# 其它
- 风险和收益[[portfolio-optimization]]
- 写代码
  - 代码[[readability]]
  - 写代码时间
  - 代码效率（[[tradeoff#时空tradeoff]]）
  - 形成多目标优化
- 模型性能和效率
  - 深度学习[[dataloader]]
  - 牺牲一点随机性，每个batch是[[contiguous]]数组中挖一点
  - 不能牺牲太多随机性否则性能肯定下降
- exploration-exploitation
  - [[multi-arm-bandit]]
  - [[mdp]]，更一般的rl