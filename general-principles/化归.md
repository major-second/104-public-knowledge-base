- 和[[oi-wiki-basic/recursion]]含义区别
  - [[oi-wiki-basic/recursion]]是问题本质不变，规模改变（往往变小）
  - 化归是本质变简单，规模不一定变小
- 局部增大规模/增加额外操作，但总体“统一化”，更简单，是化归手段！
  - 比如[[multi-ary]]一来讲到把$Wx+b$的$b$形式上写成$b \cdot x_0\equiv b\cdot 1$
  - 比如[[automation/trivial-mistakes]]需要“化归”一开始不同的环境。看起来多了一个操作，但之后更简单
  - 比如[[21-merge-two-sorted-lists]]增加链表头，方便处理空的[[special-case]]
  - 比如利用对称性“交换”化归，例如[[235-lowest-common-ancestor-of-a-binary-search-tree]]
- 通过化归也可考察可计算性和计算复杂性
  - “拿$P=NP$压人”
    - [[2-eval]]提到的：如果没有过拟合，相当于$P=NP$就解决了。所以一定会存在过拟合现象
    - [[5-constraint-satisfaction]]，[[3-search]]等很多人工智能算法也很多都在解决NP难问题，所以也当然会被“压”