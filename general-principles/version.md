# 版本号常识
- 经常是`数字.数字.数字`等几层的形式。前面是大版本号，后面是小版本号。数字越大时间越靠后
  - `3.2`肯定比`3.10`靠前
  - 也就是不能简单对字符串按字典序排序！
- 大版本号自然往往都是大改
  - 比如`python3`相对`python2`，`tf2`相对`tf1`这种，完全就当成两个东西来看比较好2333
- 有时不用数字做版本号
  - 比如[[ros/installation]]，用`a`开始的字母做版本号，越靠后的版本字母越靠后
- 安装软件，`git clone`等等时往往都要看清楚版本号
  - 例如[[aruco]]，在`git clone`时要`-b`选择正确分支
- 很多地方用`>=`，`==`，`=`等运算符表示版本号
  - 比如`>=`表示数字更大（“之后”）
  - [[conda/installation]]用`=`表示确定某个版本，[[pip]]用`==`
- 一般版本号高性能好，功能多，参考[[software-management/upgrade]]
# 常见标记
- `lts`长期支持
- `dev`开发中
  - 可能不稳定
  - 好处：多很多“开发用”的东西，比如源码，头文件等
  - 有时即使你不是在开发，在需要源码、头文件、额外组件等时也需要安装`dev`版本
- `64`或`32`对应64或32位系统
  - 有时和操作系统名称结合，如`win32`版
  - `amd64`只是说架构是AMD发明，并没有说intel的芯片就用不了
- 操作系统名：`win, linux, mac`等
- `portable`可以到处移动，而不是“安装了就动不了”
- 商业软件的`perfessional`，`extreme`等区分等级
  - 不同等级序列号不能混用（比如[[pro-license]]）
  - 有时，有序列号可以升级到高等级（[[windows/upgrade]]）
# 版本依赖相关
- 举例体验：[[pip]]中提到本地`python3.6`导致无法装`pip22`，导致无法装`tensorflow2.9`
  - 想要装该高版本`tensorflow`就必须`python3 -m pip`而不是`pip3`
  - 也就是必须用虚拟环境中的`pip`而不是本地`pip`
- 参考[[software-management/upgrade]]
  - 一般来说，很多依赖都是要求`>=`某某版本，而且上层版本越高，需求的底层版本也越高
  - 所以在两头确定时，中间可行的版本可能就只有一个范围。不能太高也不能太低
- 有些时候，兼容性比较差，就要求底层必须是某某版本范围，不是`>=`都行
  - 比如cuda10和11这种
  - 比如[[distutils]]提到的问题
  - 比如一些老旧网站（如时至2022.6中国电信网上营业厅）必须用ie模式打开才正常
    - Edge的右上角有这个按钮![](ie-mode.png)
  - 正常的软件开发习惯是用`deprecated`提醒你这个可能过一段时间就没了，你要赶紧想办法（换掉那些不推荐你再使用的api等），否则之后就别更新！
- 各级依赖之间往往有许多复杂约束，如果求解器性能不好，可能陷入死局，本来可以解的也变得不能解了（扩展阅读：[[5-constraint-satisfaction]]）
  - 所以有可能人工求解一下，然后确定几个重要节点，以帮助求解器解决
  - 碰到过的例子：`mmaction`（高级）依赖于`sklearn`（低级），`sklearn`依赖于python版本。`pip`自动求解出`sklearn`版本`1.1.1`，结果不行。于是手动在安装`mmaction`之前`pip install sklearn==1.0.2`，之后即可正常安装高层的`mmaction`
# 查看版本号
- 往往是`--version, -V, -version`等
  - 如`ffmpeg -version`
  - `python -V`
  - 特殊：`uname -a`看`ubuntu`版本