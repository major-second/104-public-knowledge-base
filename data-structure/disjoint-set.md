- https://oiwiki.org/ds/dsu/
- 基本操作的要求（这里先不涉及具体算法）
  - 初始化：每个元素的父母就是自己
  - 合并两个集合
  - 查询某个元素属于哪个集合（用树根节点表示）
- 查询
  - 朴素方法：查询时逐级向上，直到查到根节点（父母是自己）
  - 路径压缩
    - 实现1：共4行
      - 如果自己是根节点，直接返回结果
      - 递归调用查找方法，找到父母所属集合（同时把父母路径压缩）
      - 把自己路径压缩
      - 返回结果
    - 实现2：共2行
      - 如果自己不是根节点，则设置自己的父母是`find(自己父母)`
      - 返回自己父母
- 合并
  - 一种实现：`x = find(x); y = find(y); fa[x] = y;`
  - 简写一行：`fa[find(x)] = find(y);`，在[[200-number-of-islands]]就是
  - 注：c++中`union`不能用作函数名
- 启发式合并
  - 法一：个数少合并到个数多
  - 法二：维护一个rank，少的合并到多的。相等随便合且rank加一
  - 实际中偷懒不写往往也能过
  - [参考](https://oiwiki.org/ds/dsu-complexity/)