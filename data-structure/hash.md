- https://oi-wiki.org/ds/hash/
- 核心就是快速（$O(1)$地）查找
- 索引可以看成特殊的哈希，即键是整数，以**常数**时间复杂度查找
  - 例子：[[counting-sort]]
  - 例子：[[41-first-missing-positive]]方法一
    - 数组就是哈希，原地哈希不占额外空间
    - 通过正负，用一个`int`同时表示了一个`int`和一个`bool`（[[encode-decode]]思想）
  - https://leetcode.cn/problems/valid-sudoku/
    - 81个格子，每个格子以**常数**时间找到对应的地方把相应计数器加一
  - https://leetcode.cn/problems/check-permutation-lcci/
    - 对于C++可以把字符方便转化成整数，从而可用索引
    - 对于python，最简单的想法就是弄字典（哈希），这就不是索引了。这也看出索引和哈希的联系
- 把字符串对应到一个数的方法：典型就是每次`*127`再`%1000000007`（十位数）
  - 滚动计算：[[30-substring-with-concatenation-of-all-words]]
  - 拓展：如果要每个子串的哈希
    - $O(n)$
    - 即先弄每个前缀和[[partial-sum]]
    - 这样每个子串的哈希就相减可得
  - 拓展：[[49-group-anagrams]]
    - 把字符串中每个字符各出现多少次对应到一个数，也可以类似操作
    - 即“26位101进制的数，每一位表示这个字母出现多少次”
- https://leetcode.cn/problems/count-good-meals/
  - 这题说明涉及求和的，可以维护哈希表表示“某个数字出现多少次”，键是数字，值是多少次
  - 相比[[two-pointers]]，这不需要排序，是更优方法