- `import numpy as np`
- 创建array
  - `np.array([2])`这种直接得到`[2]`
  - `np.ndarray([2])`得到`.shape`（形状）是`[2]`的数组（一维数组，2个元素）
    - 默认随机初始化。如果想不随机需要`zeros`
  - `np.arange(整数)`得到0开始的连续整数，可以调试用
    - 往往结合[[numpy/reshape]]得到想要的形状
    - `-1`就是自动由其它维计算得到
  - `np.linspace(start, stop, num)`生成等差数列
    - 如应用：[[color]]
- `np.concatenate((a, b))`，返回拼接结果，不改变`a`，`b`
  - 注意不要少打一对括号
  - 元组当然可以大于2个元素
  - 除了接受元组，当然也能接受`numpy`数组（例如输入二维数组，就是对一列一维数组作concatenate）
- `np.vstack`
  - 把`[(1,2),(3,4)]`变成`2*2`的
  - 把`np.ndarray((2,), dtype=object)`这类的变成正常的（类型为数值）的array
  - [各种stack](https://blog.csdn.net/csdn15698845876/article/details/73380803)
- 切片和原来共享同样的内存，改一个就全改。这点容易导致[[python/trivial-mistakes]]类似的错误
  - 而且这个更容易误导人造成坑……毕竟python原生list可不会切片了还共享内存
  - 甚至原生list的`l[:]`还是浅拷贝的一种方式
- `np.max`和`np.amax`分别求最大值的值和下标
- array做`< > ==`等运算得到布尔的array
  - 直接用作判断条件是“ambiguous”
  - 可以`(a > 0) * a`得到`a`的正的部分
  - 可以`np.where()`筛出为`True`的那些下标，这些下标排成一列
  - 注意不能使用一元`-`变成`-1`和`0`组成的数组！
    - 但可用一元`~`否定，二元`&`、`|`（不是`&&`，`||`）
  - 结合[[quantile]]，`max`等可以找到分位数位置
    - 求分位数时会在靠近的数间作插值，所以必须先用`<`，不能一来就用`==`
- `np.clip([1,2], 0, 1.5)`输出`array([1. , 1.5])`
- `np.power(底数, 指数)`
  - 注意妥善处理涉及负数的问题。比如`np.power((a > 0) * a, alpha) - np.power((a < 0) * -a, alpha)`
- `arr`有`.mean(), .min(), .max(), .sum()`等常用方法可以直接求常用值
- `np.linalg.norm(向量)`求模长，也可以`np.linalg.norm(a - b)`求距离