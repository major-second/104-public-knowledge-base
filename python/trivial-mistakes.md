## 关于[[share-lock]]提到的“共享一个对象”问题
- 是否新建对象
  - `a={1:1}; b=a; b[2]=2; print(a)`，结果`{1: 1, 2: 2}`
  - `a={1:1}; b={1:1}; b[2]=2; print(a)`，结果`{1: 1}`
  - 表面上一开始`a==b`都成立，但是指针不同。第二种情况新建了对象，所以改`b`不影响`a`
- “金蝉脱壳”操作
  - `a={1:1}; b=a; a={1:a[1],2:2}; print(a,b)`，结果`{1: 1, 2: 2} {1: 1}`
  - `a={1:1}; b=a; a[2]=2; print(a,b)`，结果`{1: 1, 2: 2} {1: 1, 2: 2}`
- `*`和`for`区别
  - `a=[[] for _ in range(10)]; a[0]+=[1]; print(a)`效果是只有一个变了
  - `b=[[]]*10; b[0]+=[1]; print(b)`效果是全都变了
## `elif`机制
- 低级错误：结束一段后，后面错误加逗号（本来不需要逗号）
  - 这样的逗号可能表示“元组”！
  - 比如`a = 3,; print(a)`，发现结果是`(3,)`
  - 这个错误可能原因是写[[JSON常见语法]]习惯了，导致并列时习惯加逗号
- `elif`机制的一个特点
```python
a = 1
if a == 1:
    a = 2
elif a == 2:
    a = 3
```
结果是`a = 2`
- 一个改写时的错误
```python
if foo:
    <被删除>
else:
    if bar:
        ...
```
改写成了
```python
if foo:
    if bar:
        ...
```
（恰恰反了）
## 循环
- `for a, b in zip(a_list, b_list):`忘了写`zip`导致拿到`a_list`里的数据并尝试unpack
## `try`
- `except`包含一切错误一定要小心！
  - 比如测试，你想检验两个东西相等，认为比较出错就是不等，用`except`包含一切错误并`return False`
  - 但是在涉及递归地比较分量时，这样`except`就可能包含太多东西了！中间什么`assert`类型为`bool`的操作都做不了了
- 用`try`和`except`当成简单的分类讨论使用时，没有考虑`try`过程产生的副作用，导致重复操作
## 函数
- 调用函数忘了加一对括号`()`
- 方法，类方法等忘了参数`self`，`cls`等
### `lambda`与作用域
```python
s = 0
f = lambda x:s
print(f(0))
s = 1
print(f(0))
```
- 输出为`0`和`1`，也就是这里的`lambda x:s`是输出变量`s`对应的值而不是恒定输出`0`
- 这和变量`s`的作用域有关（具体地，`lambda`后`:`左边没有`s`，就把`s`认为是外面的）
- 解决方法1：设置一个“子”作用域
```python
s = 0
def create_func(s):
  return lambda x:s
f = create_func(s)
print(f(0))
s = 1
print(f(0))
```
- 解决方法2：使用带默认值的形参，使得`s`在仍然等于0时就被求值变成常量
```python
s = 0
f = lambda x, s=s:s
print(f(0))
s = 1
print(f(0))
```
## 其它
- `+=`这类语句本质上也是赋值语句，所以如果在一个作用域中出现了，就会“想覆盖外层”
  - 特别地，如果一个函数中只有一句`x+=1`，那么会覆盖外层的`x`变量，且还会报错`x`在定义前使用了
  - 所以需要`nonlocal x`
- 保存东西查看时，构造函数跑到一半就保存`self`，导致保存内容不全
  - 但是`torch.load`又可以正常load，就容易导致迷惑
  - 参考[[warning]]：这非常危险！
- `max(max([1,2,3],[0,4,5]))`结果是`3`（因为内层是两个list比较，内层输出`[1,2,3]`）
- 把已有的变量名覆盖了
  - 例如`print = 1; print(1)`显然不行
  - [[dynamic]]提到的`xlim`就有可能出现这种情况，本来应该是`plt.xlim(...)`，你要是写成`plt.xlim = ...`就会这样